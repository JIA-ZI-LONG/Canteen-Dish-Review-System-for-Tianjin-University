# TjuFood 平台详细用例说明图

本规约旨在通过用例（Use Case）的形式，详细定义“TjuFood”平台各个参与者（Actor）与系统之间的交互功能。每个用例都将从事前规划的角度进行描述，明确其触发条件、核心流程和预期成果，作为后续开发与测试的基准。

## Part 1: 用户认证与账户管理模块 (Authentication & Account Module)

此模块是整个系统的基石，定义了用户如何进入、标识和管理自己的数字身份。

| 用例ID         | **用例名称**             | **参与者**     | **前置条件**                                                 | **核心流程规约**                                             | **成功后状态**                                               |
| -------------- | ------------------------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **UC-AUTH-01** | **新用户手机号注册**     | 游客           | 无                                                           | 1. **[用户]** 在注册页面输入手机号、密码和确认密码。  2. **[系统]** 需校验手机号格式、密码强度，并验证两次输入的密码是否一致。  3. **[系统]** 需检查该手机号是否已被注册。  4. 验证通过后，**[系统]** 将密码进行BCrypt加盐哈希处理，创建新用户记录并存入数据库。 | 1. 用户账户创建成功。  2. 系统自动导航至登录页面，并提示注册成功。 |
| **UC-AUTH-02** | **获取并校验滑块验证码** | 游客, 注册用户 | 用户触发了需要人机验证的操作（如登录、重置密码）。           | 1. **[前端]** 向后端 `/api/verification/captcha` 发起请求。  2. **[后端]** 生成背景图、滑块图及滑块的正确X轴坐标。将坐标值与一个唯一的`captchaId`关联，存入Redis并设置短暂有效期。  3. **[前端]** 接收图片并渲染验证码组件。  4. **[用户]** 拖动滑块。  5. **[前端]** 将用户的滑动距离与`captchaId`提交至后端 `/api/verification/captcha/check` 进行校验。 | 1. 后端返回一个一次性的、短时效的“验证票据 (ticket)”。  2. 前端持有该票据，用于下一步的业务请求。 |
| **UC-AUTH-03** | **用户密码登录**         | 游客           | 用户已拥有账户。                                             | 1. **[用户]** 输入手机号和密码。  2. **[用户]** **`<<include>>`** **UC-AUTH-02** 完成人机验证，获取“验证票据”。  3. **[前端]** 将手机号、密码和“验证票据”提交至后端 `/api/user/login`。  4. **[后端]** 校验票据，然后查询数据库，比对BCrypt哈希后的密码。  5. 验证成功后，**[系统]** 生成`accessToken`和`refreshToken`，并将用户信息与`refreshToken`存入Redis。 | 1. 后端返回`accessToken`。  2. 前端持久化存储Token，并将用户状态更新为“已登录”。  3. 系统导航至用户首页或之前的页面。 |
| **UC-AUTH-04** | **用户登出**             | 注册用户       | 用户处于登录状态。                                           | 1. **[用户]** 点击“退出登录”按钮。  2. **[前端]** 携带`accessToken`向后端 `/api/user/logout` 发起请求。  3. **[后端]** 从`accessToken`中解析出用户标识，并从Redis中删除对应的`refreshToken`及会话信息。  4. **[前端]** 清除本地存储的所有Token和用户状态。 | 1. 用户会话在服务器和客户端均被终止。  2. 系统导航至平台首页，用户状态变为“游客”。 |
| **UC-AUTH-05** | **Token无感刷新**        | 注册用户       | 1. 用户处于登录状态。  2. `accessToken`已过期，但`refreshToken`仍在有效期内。 | 1. **[前端]** 在请求拦截器中发现API请求因`accessToken`过期而失败(e.g., HTTP 401)。  2. **[前端]** 自动向后端 `/api/user/refresh` (或其他类似接口) 发送当前持有的`refreshToken`。  3. **[后端]** 验证`refreshToken`的有效性，如果有效，则生成一个新的`accessToken`并返回。  4. **[前端]** 更新本地的`accessToken`，并用新Token重新发起之前失败的API请求。 | 1. 用户无感知地完成了`accessToken`的续期。  2. 用户操作得以继续，无需重新登录。 |
| **UC-AUTH-06** | **查看与修改个人资料**   | 注册用户       | 用户已登录。                                                 | 1. **[用户]** 进入个人资料页面。  2. **[系统]** 展示用户当前的昵称、头像等信息。  3. **[用户]** 修改昵称或 **`<<include>>`** **UC-FILE-01** 上传新头像。  4. **[系统]** 将更新后的用户信息持久化到数据库。 | 1. 用户的个人资料更新成功。  2. 页面显示最新的用户信息。     |
| **UC-AUTH-07** | **重置密码**             | 游客           | 用户忘记密码。                                               | 1. **[用户]** 在登录页面点击“忘记密码”。  2. **[用户]** 输入注册手机号，并 **`<<include>>`** **UC-AUTH-02** 完成人机验证。  3. **[系统]** （此项目简化，若有验证码则发送）验证通过后，允许用户输入新密码和确认密码。  4. **[系统]** 将新密码加密后，更新数据库中对应用户的密码字段。 | 1. 用户密码重置成功。  2. 系统导航至登录页，提示用户使用新密码登录。 |

## Part 2: 核心内容浏览与搜索模块 (Content Discovery & Search Module)

此模块定义了平台作为信息提供者的核心价值，即用户如何发现和获取餐饮信息。

| 用例ID         | **用例名称**               | **参与者**     | **前置条件**       | **核心流程规约**                                             | **成功后状态**                                               |
| -------------- | -------------------------- | -------------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **UC-DISC-01** | **按层级浏览餐饮信息**     | 游客, 注册用户 | 无                 | 1. **[用户]** 在首页或导航栏选择“全部食堂”。  2. **[系统]** 展示所有校区列表。  3. **[用户]** 点击某个校区，**[系统]** 展示该校区下的所有食堂列表。  4. **[用户]** 点击某个食堂，**[系统]** 展示该食堂的详情页，包含窗口列表。  5. **[用户]** 点击某个窗口，**[系统]** 展示该窗口的详情页，包含菜品列表和用户评价。 | 用户能够顺畅地、自顶向下地找到任何一个菜品的详细信息。       |
| **UC-DISC-02** | **查看食堂/窗口/菜品详情** | 游客, 注册用户 | 已定位到具体实体。 | 1. **[用户]** 访问任一食堂、窗口或菜品详情页。  2. **[系统]** 需从后端获取并展示该实体的所有属性，例如：  - **食堂**: 名称、楼层、营业时间、所属校区、人均消费、总体评分、窗口列表。   - **窗口**: 名称、所属食堂、主营类别、评分、图文评价列表。   - **菜品**: 名称、所属窗口、价格、评分、图片。 | 用户获得关于特定餐饮实体的全面信息。                         |
| **UC-DISC-03** | **全局关键词搜索**         | 游客, 注册用户 | 无                 | 1. **[用户]** 在顶部的搜索框输入关键词（如“牛肉面”）。  2. **[前端]** 将关键词发送至后端 `/api/search`。  3. **[后端]** 需规划一套综合搜索策略，可同时或分步查询`食堂`、`窗口`、`菜品`、`博客`等多个数据源。  4. **[后端]** 将整合后的搜索结果分类返回给前端。  5. **[系统]** （可选）记录登录用户的搜索历史。 | 系统在搜索结果页面，分类展示所有与关键词相关的食堂、菜品、博客等条目。 |
| **UC-DISC-04** | **查看热门排行榜**         | 游客, 注册用户 | 无                 | 1. **[用户]** 访问“排行榜”页面。  2. **[系统]** 需提供切换不同榜单（如“食堂好评榜”、“菜品热度榜”）的选项。  3. **[后端]** 需基于预设的算法（如加权平均分、近期评价数），通过定时任务或实时计算，从Redis或数据库中查询并返回排序后的列表。 | 用户可以看到平台内最受欢迎的食堂或菜品的排名。               |
| **UC-DISC-05** | **查看平台公告**           | 游客, 注册用户 | 无                 | 1. **[用户]** 在首页或“消息中心”点击“公告”。  2. **[系统]** 展示由管理员发布的、按时间倒序排列的公告列表。  3. **[用户]** 点击任一公告标题可查看详情。 | 用户获取到平台的官方信息和活动通知。                         |

## Part 3: 用户生成内容 (UGC) 与社区互动模块

这是平台社区生态的核心，定义了用户如何贡献内容并与其他用户互动。

| 用例ID        | **用例名称**          | **参与者**     | **前置条件**                                           | **核心流程规约**                                             | **成功后状态**                                               |
| ------------- | --------------------- | -------------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **UC-UGC-01** | **发布窗口图文评价**  | 注册用户       | 1. 用户已登录。  2. 用户已定位到某个特定窗口的详情页。 | 1. **[用户]** 在窗口详情页点击“写评价”。  <br />2. **[系统]** 提供评分（1-5星）、文本输入框和图片上传功能。  3. **[用户]** 完成内容填写并提交。 **`<<extend>>`** **UC-FILE-01** 上传图片。  4. **[后端]** 需对提交的文本内容进行 **`<<include>>`** **UC-SEC-01** 敏感词过滤。  5. 过滤通过后，将评价内容存入数据库，并将其状态置为“待审核”。 | 1. 用户的评价提交成功。  2. 系统提示“评价已提交，等待审核”。  3. 该评价在审核通过前，对自己可见，对他人不可见。 |
| **UC-UGC-02** | **发布美食博客**      | 注册用户       | 用户已登录。                                           | 1. **[用户]** 点击“发布博客”按钮。  2. **[系统]** 提供富文本编辑器（TipTapEditor），支持标题、正文、图片插入、关联食堂/菜品等功能。  3. **[用户]** 编辑完成并发布。  4. **[后端]** 同样需进行 **`<<include>>`** **UC-SEC-01** 敏感词过滤，并通过后存入数据库，状态为“待审核”。 | 1. 用户博客提交成功。  2. 流程与评价发布类似，内容进入审核流程。 |
| **UC-UGC-03** | **对内容进行评论**    | 注册用户       | 1. 用户已登录。  2. 用户正在查看某个博客或评价的详情。 | 1. **[用户]** 在评论区输入文本并提交。  2. **[后端]** 需进行 **`<<include>>`** **UC-SEC-01** 敏感词过滤。  3. 通过后，将评论内容与被评论的内容ID及用户信息关联，存入数据库。  4. **[系统]** 需规划向被评论内容的作者发送一条新消息通知。 | 1. 评论发布成功，并立即显示在评论区。  2. 内容作者会收到一条通知。 |
| **UC-UGC-04** | **对内容进行点赞**    | 注册用户       | 用户已登录。                                           | 1. **[用户]** 点击博客或评价旁边的“点赞”按钮。  2. **[前端]** 立即将点赞按钮状态切换为“已点赞”，并更新点赞数（前端优化）。  3. **[前端]** 异步向后端发送点赞请求。  4. **[后端]** 使用Redis的Set结构记录点赞关系（`like:blog:{blogId}` -> `userId`），以支持快速判断和取消点赞，并异步更新数据库中的总点赞数。 | 1. 用户点赞成功。  2. 再次点击可取消点赞。                   |
| **UC-UGC-05** | **收藏/取消收藏内容** | 注册用户       | 用户已登录。                                           | 1. **[用户]** 点击博客或食堂旁的“收藏”按钮。  2. 流程与点赞类似，前端立即响应，后端异步处理。  3. **[后端]** 需将收藏记录存入`tb_favorite`表，记录用户ID和被收藏实体的ID及类型。 | 1. 内容被成功添加至用户的“我的收藏”列表。  2. 用户可在个人中心查看自己所有的收藏。 |
| **UC-UGC-06** | **查看个人动态/主页** | 游客, 注册用户 | 无                                                     | 1. **[用户]** 点击某个用户的头像或昵称。  2. **[系统]** 导航至该用户的个人主页。  3. 页面需展示该用户的基本信息、发布的博客列表、评价列表等。 | 用户可以查看平台上任何一个内容贡献者的公开活动记录。         |

## Part 4: 运营与激励模块 (Operation & Incentive Module)

此模块旨在提升用户活跃度和粘性，并为平台运营提供必要的工具。

| 用例ID       | **用例名称**           | **参与者** | **前置条件**                                           | **核心流程规约**                                             | **成功后状态**                                               |
| ------------ | ---------------------- | ---------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **UC-OP-01** | **每日签到**           | 注册用户   | 用户已登录，且当日未签到。                             | 1. **[用户]** 在首页或任务中心点击“签到”。  2. **[后端]** 需使用Redis的Bitmap结构（`sign:{userId}:{yyyyMM}`）来记录用户当月的签到状态。  3. 通过`SETBIT`命令将当天对应的位（bit）设为1。  4. **[后端]** 根据积分规则，为用户增加签到积分，并记录积分流水。 | 1. 用户签到成功，按钮变为“已签到”。  2. 用户的积分增加。  3. 系统可计算并展示用户的连续签到天数。 |
| **UC-OP-02** | **抢购秒杀优惠券**     | 注册用户   | 1. 用户已登录。  2. 管理员已发布秒杀券，且活动已开始。 | 1. **[后端]** 在活动开始前，需将优惠券库存预热到Redis中。  2. **[用户]** 点击“立即抢购”。  3. **[后端]** **`<<include>>`** **UC-SEC-02** 执行基于Redis+Lua的原子化库存判断与扣减，判断库存和用户购买资格（一人一单）。  4. 判断通过后，**[后端]** 立即将订单信息（`orderId`, `userId`, `voucherId`）发送至RabbitMQ消息队列，并向前端返回成功。  5. 一个独立的 **[订单处理监听器]** 消费消息，执行数据库层面的订单创建和库存扣减。 | 1. 前端收到近乎瞬时的成功反馈。  2. 用户在“我的优惠券”中能看到抢到的券（在后台处理完毕后）。  3. 系统成功应对高并发场景，未发生超卖。 |
| **UC-OP-03** | **查看个人积分与通知** | 注册用户   | 用户已登录。                                           | 1. **[用户]** 访问“我的”页面或消息中心。  <br />2. **[系统]** 从后端拉取并展示用户当前的积分总额、积分明细，以及未读的系统/互动通知列表。  3. 用户可将通知标记为已读。 | 用户清晰地了解自己的积分情况和收到的互动信息。               |

## Part 5: 后台管理模块 (Admin Panel Module)

此模块为平台管理者提供支持，确保平台内容准确、社区健康、系统可控。

| 用例ID        | **用例名称**           | **参与者**                         | **前置条件**   | **核心流程规约**                                             | **成功后状态**                                       |
| ------------- | ---------------------- | ---------------------------------- | -------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| **UC-ADM-01** | **后台用户登录**       | 内容管理员, 社区管理员, 超级管理员 | 拥有后台账户。 | 与 **UC-AUTH-03** 流程类似，但使用独立的后台登录接口 `/api/admin/login` 和独立的JWT/Session管理机制。 | 管理员成功登录后台管理系统，并看到其权限对应的菜单。 |
| **UC-ADM-02** | **管理餐饮基础数据**   | 内容管理员                         | 管理员已登录。 | 提供对`校区`、`食堂`、`食堂分类`、`窗口`、`窗口分类`、`菜品`信息的完整CRUD（创建、读取、更新、删除）操作界面。所有操作需记录操作日志。 | 平台的基础信息（菜单、地点等）得到及时、准确的更新。 |
| **UC-ADM-03** | **审核用户生成内容**   | 社区管理员                         | 管理员已登录。 | 1. **[系统]** 在后台提供“内容审核”列表，展示所有待审核的评价和博客。  2. **[管理员]** 可查看内容详情，并执行“通过”或“驳回”操作。  3. 若“通过”，则将对应内容的状态更新为“已发布”，并对所有用户可见。  4. 若“驳回”，则内容状态更新为“审核失败”，并可选择向用户发送一条驳回理由的通知。 | 社区内容的质量得到有效控制。                         |
| **UC-ADM-04** | **管理用户信息**       | 社区管理员                         | 管理员已登录。 | 提供用户列表的查看、搜索功能。可对违规用户执行“禁用账户”或“解禁账户”操作。被禁用的用户将无法登录。 | 平台的社区秩序得到维护。                             |
| **UC-ADM-05** | **管理举报信息**       | 社区管理员                         | 管理员已登录。 | 提供举报列表，展示被举报的内容、举报人、举报理由。管理员可据此对被举报内容或发布者进行处理。 | 用户的负面反馈得到响应和处理。                       |
| **UC-ADM-06** | **管理平台运营内容**   | 超级管理员                         | 管理员已登录。 | 提供对`首页轮播图`、`公告`、`优惠券活动`、`积分规则`的增删改查功能。 | 平台的运营活动能够灵活配置和发布。                   |
| **UC-ADM-07** | **管理后台角色与权限** | 超级管理员                         | 管理员已登录。 | 1. **[系统]** 提供`权限点`列表（如 "user:add", "canteen:delete"）。  2. **[管理员]** 可创建`角色`（如 “实习内容运营”），并为角色勾选其拥有的`权限点`。  3. **[管理员]** 可创建或修改后台`管理员账户`，并为其分配一个或多个`角色`。 | 系统实现精细化的、基于角色（RBAC）的后台权限控制。   |
| **UC-ADM-08** | **查看系统数据看板**   | 超级管理员                         | 管理员已登录。 | 提供一个集中的Dashboard页面，通过图表可视化展示核心运营指标，如：每日新增用户数、日活跃用户（DAU）、帖子发布量、平台核心数据总量等。 | 管理层能够快速掌握平台运营的宏观状况。               |
| **UC-ADM-09** | **查看与导出操作日志** | 超级管理员                         | 管理员已登录。 | 系统需规划一个AOP切面，自动记录所有后台关键操作的日志（操作人、时间、IP、接口、参数）。后台需提供界面供管理员按条件查询和导出这些日志。 | 所有后台操作都有迹可循，便于审计和问题追溯。         |

## Part 6: 公共与安全模块 (Common & Security Module)

此模块包含被其他多个用例引用或依赖的横切关注点。

| 用例ID         | **用例名称**            | **参与者** | **前置条件**                                                 | **核心流程规约**                                             | **成功后状态**                                           |
| -------------- | ----------------------- | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| **UC-FILE-01** | **上传文件到对象存储**  | 注册用户   | 需要上传图片。                                               | 1. **[前端]** 调用文件选择框。  2. **[后端]** 提供文件上传接口 `/api/file/upload`。  3. **[后端]** 接收到文件后，上传至MinIO私有桶，并为该文件生成一个有时效性的预签名URL。 | 后端返回该文件的预签名URL，前端可用此URL进行展示或提交。 |
| **UC-SEC-01**  | **文本敏感词过滤**      | (系统内部) | 任何用户输入的文本内容（评价、博客、评论、昵称）需要持久化之前。 | **[后端]** 在Service层，需设计一个敏感词过滤工具。可将敏感词库加载到内存（如AC自动机）或Redis中，对输入文本进行高效匹配和替换（如替换为 `*`）。 | 含有敏感词的文本被拒绝或处理后，才允许存入数据库。       |
| **UC-SEC-02**  | **执行Redis原子化操作** | (系统内部) | 在高并发场景下，需要对Redis数据进行“先判断、后修改”的操作时（如秒杀）。 | **[后端]** 需将多个Redis命令封装在一个Lua脚本中，通过`EVAL`或`EVALSHA`命令一次性发送给Redis执行，利用Redis的单线程特性保证操作的原子性。 | 避免了在分布式高并发场景下的数据不一致问题（如超卖）。   |