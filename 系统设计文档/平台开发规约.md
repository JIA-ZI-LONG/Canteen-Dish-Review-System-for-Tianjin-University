# TjuFood 平台开发规约

**版本: 1.0**

**文档目的**: 本规约旨在为 “TjuFood” 项目的所有参与者提供一套统一的、必须遵守的开发标准和最佳实践。它结合了行业共识与本项目的技术选型，确立了从编码、数据库设计到安全实现的全方位准则。**本规约的愿景是：码出高效，码出质量。**

## 一、 编程规约

### (一) 命名风格

1. **【强制】** 所有编程相关的命名（项目、包、类、方法、变量、常量、数据库字段）均不能以下划线或美元符号开始或结束。
2. **【强制】** 严禁使用拼音与英文混合的方式，更不允许直接使用中文。国际通用的名称（如 `tianjin`, `beijing`）可视同英文。
3. **【强制】** **类名**需采用大驼峰命名法 (UpperCamelCase)。
   - **正例**: `StallServiceImpl`, `RedisConstants`, `UserDTO`。
   - **反例**: `stallService`, `redis_constants`。
4. **【强制】** **方法名、参数名、成员变量、局部变量**需采用小驼峰命名法 (lowerCamelCase)。
   - **正例**: `getUserById(Long userId)`, `String stallName`。
5. **【强制】** **常量**命名需全部大写，单词间用下划线隔开。
   - **正例**: `RedisConstants.LOGIN_USER_TTL`。
   - **反例**: `loginUserTtl`。
6. **【强制】** **包名**需统一使用小写，点分隔符之间有且仅有一个自然语义的单词，且使用单数形式。
   - **正例**: `xyz.tjucomments.tjufood.controller`, `xyz.tjucomments.tjufood.utils.lock`。
7. **【强制】** **布尔类型的变量**在POJO中，都不要加 `is` 前缀，以避免部分RPC或ORM框架的反序列化问题。
   - **正例**: `private Boolean deleted;` 其getter方法为 `getDeleted()`。
   - **反例**: `private Boolean isDeleted;`
8. **【推荐】** 各层领域模型命名需遵循以下规约：
   - **数据对象 (DO)**: `xxxDO`，与数据库表结构一一对应。正例: `User.java`, `Canteen.java` (在此项目中，Entity类即为DO)。
   - **数据传输对象 (DTO)**: `xxxDTO`，用于Service层与Controller层之间的数据传输。正例: `LoginFormDTO.java`, `DishDTO.java`。
   - **展示对象 (VO)**: `xxxVO`，用于Controller层向前端返回的对象。正例: `AdminInfoVO.java`, `LoginSuccessVO.java`。

### (二) 代码格式

1. **【强制】** 使用4个空格进行缩进，严禁使用Tab字符。
2. **【强制】** 单行字符数限制不超过 **120** 个，超出需换行。换行规则遵循手册，如：运算符与下文一起换行。
3. **【强制】** 方法参数在定义和传入时，多个参数的逗号后必须加空格。
4. **【强制】** IDE的文本文件编码需统一设置为 **UTF-8**。

### (三) OOP规约

1. **【强制】** 所有的覆写方法，必须添加 `@Override` 注解。
2. **【强制】** 所有整型包装类对象之间值的比较，**全部使用 `equals` 方法**。
   - **说明**: `Integer` 在 `-128` 至 `127` 之间会复用对象，超出此范围则不会。为避免隐患，禁止使用 `==` 进行比较。
3. **【强制】** POJO类属性必须使用包装数据类型。RPC方法的返回值和参数必须使用包装数据类型。所有的局部变量推荐使用基本数据类型。
   - **说明**: 包装类型的 `null` 值可以代表额外信息，如“远程调用失败”、“数据不存在”等，可有效防止在自动拆箱时产生NPE。本项目所有 `entity` 和 `dto` 包下的类都必须遵循此规则。
4. **【强制】** POJO类中禁止设定任何属性默认值。
5. **【强制】** 构造方法里禁止加入任何业务逻辑，如有初始化逻辑，需放在 `init` 方法中。
6. **【强制】** POJO类必须覆写 `toString` 方法。当有父类时，需在开头调用 `super.toString()`。

### (四) 集合处理

1. **【强制】** 判断所有集合内部的元素是否为空，需使用 `isEmpty()` 方法，而不是 `size() == 0`。
2. **【强制】** 使用集合转数组的方法，必须使用集合的 `toArray(T[] array)` 方法，传入类型完全一致、长度为0的空数组。
   - **正例**: `String[] array = list.toArray(new String[0]);`
3. **【推荐】** 集合初始化时，尽量指定初始值大小，以避免频繁的动态扩容。
   - **正例**: `Map<String, Object> map = new HashMap<>(16);`

### (五) 并发处理

1. **【强制】** 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
   - **正例**: 项目中已配置 `ThreadPoolConfig.java`，所有异步任务必须通过此线程池执行。
2. **【强制】** 线程池不允许使用 `Executors` 去创建，而必须通过 `ThreadPoolExecutor` 的方式。
   - **说明**: `Executors` 返回的线程池（如 `FixedThreadPool`）可能存在请求队列长度无限制的问题，有导致OOM的风险。`ThreadPoolConfig.java` 中的实现即为本项目的标准。
3. **【强制】** `SimpleDateFormat` 是线程不安全的类，禁止定义为 `static` 变量。若需共享，必须加锁或使用 `ThreadLocal` 包装。
   - **推荐**: 在JDK 8及以上版本，全面使用 `Instant` 代替 `Date`，`LocalDateTime` 代替 `Calendar`，`DateTimeFormatter` 代替 `SimpleDateFormat`。
4. **【强制】** 高并发场景下，对共享资源的修改需加锁。本项目中，对Redis的并发操作，需使用**分布式锁**。
   - **正例**: 秒杀业务中使用的 `SimpleRedisLock.java`，它基于 `SETNX` 指令实现，是解决此类问题的标准方案。

## 二、 异常与日志规约

### (一) 错误码

1. **【强制】** 错误码需遵循 **“A/B/C分类 + 四位数字编号”** 的原则。
   - **A**: 用户端错误（如参数非法、权限不足）。
   - **B**: 系统内部错误（业务逻辑异常、程序健壮性问题）。
   - **C**: 第三方服务错误（调用外部API、中间件异常）。
   - **正例**:
     - `A0410`: 请求必填参数为空 (`LoginFormDTO` 中字段校验失败)。
     - `B0100`: 系统执行超时。
     - `C0130`: 缓存服务出错 (Redis连接异常)。
   - **说明**: `GlobalExceptionHandler.java` 中捕获的异常，需根据其性质转换为对应的错误码返回给前端。
2. **【强制】** 错误码不能直接作为提示信息输出给用户。返回给前端的 `Result` 对象需包含 `code`, `errorMessage`, `userTip` 等字段。

### (二) 异常处理

1. **【强制】** `RuntimeException`（如 `NullPointerException`）不应该通过 `catch` 的方式来处理，必须通过预检查（如 `if (obj != null)`）来规避。
2. **【强制】** 事务场景中，若 `catch` 异常后希望回滚，必须手动抛出 `RuntimeException` 或调用 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()`。
3. **【强制】** `finally` 块中禁止使用 `return`。

### (三) 日志规约

1. **【强制】** 应用中不可直接使用 `Log4j`、`Logback` 的API，必须依赖 **SLF4J** 门面框架。
   - **正例**: `private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);`
2. **【强制】** 日志输出时，字符串变量拼接必须使用占位符 `{}`。
   - **正例**: `logger.info("Processing user login for: {}", loginForm.getPhone());`
3. **【强制】** 对于 `trace/debug/info` 级别的日志，输出前必须进行日志级别的判断。
   - **正例**: `if (logger.isDebugEnabled()) { logger.debug("User {} detail: {}", id, user.toString()); }`
4. **【强制】** 异常信息打印必须包含**案发现场信息**和**异常堆栈信息**。
   - **正例**: `logger.error("Failed to process order with id: {}", orderId, e);`
5. **【推荐】** 生产环境禁止输出 `debug` 日志，谨慎选择性输出 `info` 日志。`warn` 级别可用于记录用户参数错误等非预期但非系统错误的情况。`error` 级别仅用于记录系统逻辑出错、严重异常等情况。

## 三、 数据库规约 (SQL Server)

1. **【强制】** **表达“是/否”概念的字段**，必须命名为 `is_xxx`，数据类型为 `unsigned tinyint` (1表示是, 0表示否)。
   - **说明**: POJO中对应的属性为 `Boolean xxx`，需在MyBatis的 `<resultMap>` 中明确配置映射关系。
2. **【强制】** **表名、字段名**必须使用小写字母或数字，单词间用下划线分隔。
   - **正例**: `tb_user`, `canteen_name`。
3. **【强制】** **主键索引**名为 `pk_`+字段名；**唯一索引**名为 `uk_`+字段名；**普通索引**名为 `idx_`+字段名。
4. **【强制】** **小数类型**必须使用 `decimal`，禁止使用 `float` 和 `double`。
5. **【强制】** **表必备三字段**: `id` (bigint unsigned, 主键), `create_time` (datetime), `update_time` (datetime)。
6. **【强制】** 禁止使用物理删除，必须使用**逻辑删除**。
   - **正例**: 使用 `is_deleted` 字段标识，`1`为已删除，`0`为未删除。
7. **【强制】** 在SQL查询中，严禁使用 `*` 作为查询字段列表，必须明确写出所需字段。
8. **【强制】** **ORM映射**中，sql.xml配置参数必须使用 `#{}`，禁止使用 `${}` 以防SQL注入。

## 四、 工程结构规约

1. **【强制】** **应用分层**: 项目严格遵循以下分层结构：
   - **终端显示层 (user-frontend, admin-frontend)**
   - **请求处理层 (Controller)**: `xyz.tjucomments.tjufood.controller` 包。负责接口暴露、基本参数校验和请求转发。
   - **业务逻辑层 (Service)**: `xyz.tjucomments.tjufood.service` 接口及其 `impl` 实现包。负责核心业务逻辑处理。
   - **通用处理层 (Manager/Utils)**: 如 `xyz.tjucomments.tjufood.utils` 包。封装通用能力，如缓存客户端 `CacheClient`、分布式ID生成器 `RedisIdWorker` 等。
   - **数据持久层 (DAO/Mapper)**: `xyz.tjucomments.tjufood.mapper` 包。负责与数据库进行直接交互。
2. **【强制】** **依赖管理 (Maven)**:
   - 所有 pom.xml 文件中的依赖声明放在 `<dependencies>` 块中。
   - 所有依赖的版本仲裁必须在父 `pom.xml` 的 `<dependencyManagement>` 块中统一管理。
   - 禁止在子项目的 `pom` 依赖中出现相同的GroupId、ArtifactId但不同的Version。

## 五、 安全规约

1. **【强制】** **权限校验**: 所有隶属于用户个人的页面或功能接口，必须进行严格的权限控制。
   - **说明**: `LoginInterceptor` 必须确保用户已登录。在处理具体业务时，如“修改订单”，必须校验该订单是否属于当前登录用户。
2. **【强制】** **防SQL注入**: 所有数据库操作必须通过MyBatis-Plus的参数绑定 (`#{}`) 来实现，严禁任何形式的字符串拼接SQL。
3. **【强制】** **防XSS攻击**: 对所有用户输入并可能在前端展示的内容（如昵称、评价、博客），后端需进行安全过滤，或前端在展示时进行HTML转义。`XssUtils.java` 可作为基础工具。
4. **【强制】** **防CSRF攻击**: 前后端分离架构下，通过JWT的Token机制，配合校验请求头中的`Origin`和`Referer`，可有效防御CSRF。
5. **【强制】** **防刷与重放**: 对所有调用外部资源（如短信、邮件）或进行关键操作（支付、下单）的接口，必须实现防刷机制（如基于Redis的IP/用户ID限流）。`RateLimitUtils.java` 可提供基础能力。
6. **【强制】** **密码安全**: 配置文件（`application.yaml`）中所有敏感信息（如数据库密码、Redis密码）必须加密存放，不能以明文形式出现。